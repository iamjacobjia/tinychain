//! [What is a NetworkBehaviour](https://docs.rs/libp2p/latest/libp2p/swarm/trait.NetworkBehaviour.html)

use std::{
    collections::{hash_map::DefaultHasher, HashMap},
    hash::{Hash, Hasher},
    io,
    time::Duration,
};

use either::Either;
use libp2p::{
    gossipsub::{self, IdentTopic, TopicHash},
    identify,
    identity::Keypair,
    ping,
    request_response::RequestId,
    swarm::{ConnectionHandlerUpgrErr, NetworkBehaviour},
    Multiaddr, PeerId,
};
use tokio::sync::oneshot;

pub mod discovery;
pub mod req_resp;

use crate::{config::ReqRespConfig, error::Error};

/// BehaviourErr combines all possible errors generated by the subbehaviours.
pub type BehaviourErr = Either<
    Either<
        Either<Either<io::Error, io::Error>, ping::Failure>,
        ConnectionHandlerUpgrErr<io::Error>,
    >,
    void::Void,
>;

/// The topic of a gossipsub message.
#[derive(Debug)]
pub enum Topic {
    Block,
    Tx,
}

impl From<TopicHash> for Topic {
    fn from(hash: TopicHash) -> Self {
        let topic = gossipsub::IdentTopic::new("tx");
        if topic.hash() == hash {
            Self::Tx
        } else {
            Self::Block
        }
    }
}

impl From<Topic> for String {
    fn from(topic: Topic) -> Self {
        match topic {
            Topic::Block => "block".to_string(),
            Topic::Tx => "tx".to_string(),
        }
    }
}

#[derive(NetworkBehaviour)]
pub struct Behaviour {
    /// Discovers peers in the network.
    discovery: discovery::Behaviour,
    /// Periodically exchanges infomation with known peers.
    identify: identify::Behaviour,
    /// Periodically pings connected peers.
    ping: ping::Behaviour,
    /// Generic request-response behaviour.
    req_resp: req_resp::Behaviour,
    /// Publishes and subscribes to topics.
    gossipsub: gossipsub::Behaviour,
}

impl Behaviour {
    /// Create a new `Behaviour` with the given local keypair and request-response configuration.
    pub fn new(local_key: Keypair, req_resp_config: Option<ReqRespConfig>) -> Result<Self, Error> {
        let local_pubkey = local_key.public();
        let local_peer_id = local_pubkey.to_peer_id();

        let id_behaviour = identify::Behaviour::new(identify::Config::new(
            "/tinychain/identify/1.0.0".to_string(),
            local_pubkey,
        ));

        Ok(Self {
            discovery: discovery::Behaviour::new(local_peer_id),
            identify: id_behaviour,
            ping: ping::Behaviour::default(),
            req_resp: Self::new_req_resp(req_resp_config),
            gossipsub: Self::new_gossipsub(local_key)?,
        })
    }

    /// Send an outbound request to the target.
    pub fn send_request(
        &mut self,
        target: &PeerId,
        request: Vec<u8>,
        responder: oneshot::Sender<Result<Vec<u8>, Error>>,
    ) {
        self.req_resp.send_request(target, request, responder);
    }

    /// Send a response to the request.
    pub fn send_response(&mut self, request_id: RequestId, response: Result<Vec<u8>, ()>) {
        self.req_resp.send_response(request_id, response);
    }

    /// Broadcast a message to the network.
    pub fn broadcast(&mut self, topic: Topic, message: Vec<u8>) -> Result<(), Error> {
        let topic = gossipsub::IdentTopic::new(topic);
        self.gossipsub.publish(topic, message)?;

        Ok(())
    }

    /// Get known peers in the network.
    pub fn known_peers(&mut self) -> HashMap<PeerId, Vec<Multiaddr>> {
        self.discovery.known_peers()
    }

    /// Add an address to the DHT.
    pub fn add_address(&mut self, peer_id: &PeerId, addr: Multiaddr) {
        self.discovery.add_address(peer_id, addr);
    }

    /// Remove a peer from the DHT.
    pub fn remove_peer(&mut self, peer_id: &PeerId) {
        self.discovery.remove_peer(peer_id);
    }

    fn new_req_resp(config: Option<ReqRespConfig>) -> req_resp::Behaviour {
        if let Some(config) = config {
            return req_resp::BehaviourBuilder::new()
                .with_connection_keep_alive(config.connection_keep_alive)
                .with_request_timeout(config.request_timeout)
                .with_max_request_size(config.max_request_size)
                .with_max_response_size(config.max_response_size)
                .build();
        }

        req_resp::BehaviourBuilder::default().build()
    }

    fn new_gossipsub(local_key: Keypair) -> Result<gossipsub::Behaviour, Error> {
        let message_id_fn = |message: &gossipsub::Message| {
            let mut s = DefaultHasher::new();
            message.data.hash(&mut s);
            gossipsub::MessageId::from(s.finish().to_string())
        };

        let gossipsub_config = gossipsub::ConfigBuilder::default()
            .heartbeat_interval(Duration::from_secs(10))
            .validation_mode(gossipsub::ValidationMode::Strict)
            .message_id_fn(message_id_fn)
            .build()
            .map_err(|err| Error::PubsubBuildError(err.to_string()))?;

        let mut gossipsub = gossipsub::Behaviour::new(
            gossipsub::MessageAuthenticity::Signed(local_key),
            gossipsub_config,
        )
        .map_err(|err| Error::PubsubBuildError(err.to_string()))?;

        // These topics are compulsory for all peers.
        let tx_topic = IdentTopic::new(Topic::Tx);
        let block_topic = IdentTopic::new(Topic::Block);
        gossipsub.subscribe(&tx_topic)?;
        gossipsub.subscribe(&block_topic)?;

        Ok(gossipsub)
    }
}
